{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Acceso a Datos - IntelliJ"},{"location":"Idea/","text":"\ud83d\udd39IntelliJ IDEA Ultimate IntelliJ IDEA ya lo conoc\u00e9is, porque lo hab\u00e9is estado utilizando en el m\u00f3dulo de programaci\u00f3n de primero, no obstante, en el apartado de Instalaci\u00f3n ten\u00e9is algunas indicaciones sobre su descarga e instalaci\u00f3n. En el apartado de Configuraci\u00f3n ten\u00e9is las indicaciones para crear cada uno de los proyectos correspondientes a cada UD de este m\u00f3dulo. \ud83d\udd39Instalaci\u00f3n En el momento de realizar estos apuntes la \u00faltima versi\u00f3n es la 2025 . El enlace para su descarga es https://www.jetbrains.com/idea/ . Seleccionamos Download y descargamos la versi\u00f3n Ultimate , que es la que nos proporcionar\u00e1 todas las herramientas para poder trabajar sin problemas. Licencia Para obtener una licencia de estudiante , que elimine la restricci\u00f3n de una versi\u00f3n de prueba de 30 d\u00edas, es neceasario que la solicit\u00e9is en el enlace correspondiente y rellen\u00e9is los datos del formulario: \ud83d\udd39Configuraci\u00f3n Cuando creamos un nuevo proyecto en IntelliJ IDEA, el IDE nos ofrece diferentes configuraciones y plantillas iniciales: Java, Kotlin, proyectos con Gradle o Maven , aplicaciones Android, entre otras. Gradle y Maven son unas herramientas de automatizaci\u00f3n de construcci\u00f3n de proyectos (build tool) muy utilizadas en el desarrollo de software.Se encargan de compilar, ejecutar, probar y empaquetar un proyecto, adem\u00e1s de gestionar de forma autom\u00e1tica las librer\u00edas externas que necesita. En este m\u00f3dulo nos centraremos en estas configuraciones: Kotlin simple para ejercicios b\u00e1sicos. Kotlin con Gradle para manejo avanzado de ficheros y bases de datos. Kotlin con Maven y complemento Spring para proyectos web y APIs con Spring Boot. Sin Gradle Con Gradle \ud83d\udd39Proyecto nuevo Una vez elegida la configuraci\u00f3n del proyecto seg\u00fan nuestras necesidades, se genera autom\u00e1ticamente la estructura de carpetas donde guardaremos nuestros programas. Dentro de la carpeta src podemos a\u00f1adir directamente los archivos Kotlin o, si lo preferimos, crear paquetes para organizar mejor el c\u00f3digo. | | En los proyectos creados con Gradle la estructura de carpetas var\u00eda ligeramente. Para a\u00f1adir nuestros programas debemos ir a la ruta src/main/kotlin , mientras que en la ra\u00edz del proyecto tambi\u00e9n se genera la carpeta resources (destinada a archivos auxiliares como datos o configuraciones) y los ficheros de configuraci\u00f3n propios de Gradle , como build.gradle.kts . | | \ud83d\udd39Estructura de los proyectos por UD Por cada UD se crear\u00e1n uno o varios proyectos con una estructura fija para facilitar su correcci\u00f3n. \ud83d\udd39UD Ficheros En esta unidad crearemos dos proyectos: Un proyecto sin Gradle , que llamaremos Ficheros , destinado a todos los ejemplos relacionados con el sistema de ficheros y el manejo de archivos. En este proyecto crearemos tres paquetes (sistema, contenido y formatos) para organizar los diferentes ejemplos. Un proyecto con Gradle , que llamaremos Ficheros_Gradle , en el que trabajaremos con ficheros de distintos formatos. A lo largo del tema se ir\u00e1 indicando en qu\u00e9 carpeta debe colocarse cada ejemplo. Proyecto Ficheros Proyecto Fichero_Gradle \ud83d\udd39UD BD Relacionales Para esta unidad did\u00e1ctica, crearemos un proyecto llamado BDRelacionales , configurado con Gradle . Este proyecto se utilizar\u00e1 para realizar todos los ejemplos y ejercicios relacionados con el acceso a bases de datos relacionales desde Kotlin. Con el fin de mantener una estructura organizada y diferenciada seg\u00fan el tipo de base de datos, se crear\u00e1n dos paquetes: Postgres : donde se incluir\u00e1n todos los ejemplos orientados al uso de bases de datos PostgreSQL. SQLite : donde se desarrollar\u00e1n los ejemplos utilizando bases de datos SQLite, tanto embebidas como externas. En cada apartado se especificar\u00e1 en qu\u00e9 paquete debe desarrollarse cada ejercicio, seg\u00fan la base de datos utilizada. \ud83d\udd39UD BD Documentales Para esta unidad did\u00e1ctica, crearemos un proyecto llamado BDNoSQL , configurado con Gradle . Este proyecto se utilizar\u00e1 para realizar todos los ejemplos y ejercicios relacionados con el acceso a Bases de Datos documentales desde Kotlin. Con el fin de mantener una estructura organizada y diferenciada seg\u00fan el controlador utilizado, se crear\u00e1n dos paquetes: mongo : donde se incluir\u00e1n los ejemplos en los que se utiliza el driver oficial de Mongo. kmongo : donde se incluir\u00e1n los ejemplos en los que se utiliza el driver KMongo. En cada apartado se especificar\u00e1 en qu\u00e9 paquete debe desarrollarse cada ejercicio, seg\u00fan el controlador utilizado.","title":"\ud83d\udd39IntelliJ IDEA Ultimate"},{"location":"Idea/#intellij-idea-ultimate","text":"IntelliJ IDEA ya lo conoc\u00e9is, porque lo hab\u00e9is estado utilizando en el m\u00f3dulo de programaci\u00f3n de primero, no obstante, en el apartado de Instalaci\u00f3n ten\u00e9is algunas indicaciones sobre su descarga e instalaci\u00f3n. En el apartado de Configuraci\u00f3n ten\u00e9is las indicaciones para crear cada uno de los proyectos correspondientes a cada UD de este m\u00f3dulo.","title":"\ud83d\udd39IntelliJ IDEA Ultimate"},{"location":"Idea/#instalacion","text":"En el momento de realizar estos apuntes la \u00faltima versi\u00f3n es la 2025 . El enlace para su descarga es https://www.jetbrains.com/idea/ . Seleccionamos Download y descargamos la versi\u00f3n Ultimate , que es la que nos proporcionar\u00e1 todas las herramientas para poder trabajar sin problemas. Licencia Para obtener una licencia de estudiante , que elimine la restricci\u00f3n de una versi\u00f3n de prueba de 30 d\u00edas, es neceasario que la solicit\u00e9is en el enlace correspondiente y rellen\u00e9is los datos del formulario:","title":"\ud83d\udd39Instalaci\u00f3n"},{"location":"Idea/#configuracion","text":"Cuando creamos un nuevo proyecto en IntelliJ IDEA, el IDE nos ofrece diferentes configuraciones y plantillas iniciales: Java, Kotlin, proyectos con Gradle o Maven , aplicaciones Android, entre otras. Gradle y Maven son unas herramientas de automatizaci\u00f3n de construcci\u00f3n de proyectos (build tool) muy utilizadas en el desarrollo de software.Se encargan de compilar, ejecutar, probar y empaquetar un proyecto, adem\u00e1s de gestionar de forma autom\u00e1tica las librer\u00edas externas que necesita. En este m\u00f3dulo nos centraremos en estas configuraciones: Kotlin simple para ejercicios b\u00e1sicos. Kotlin con Gradle para manejo avanzado de ficheros y bases de datos. Kotlin con Maven y complemento Spring para proyectos web y APIs con Spring Boot. Sin Gradle Con Gradle","title":"\ud83d\udd39Configuraci\u00f3n"},{"location":"Idea/#proyecto-nuevo","text":"Una vez elegida la configuraci\u00f3n del proyecto seg\u00fan nuestras necesidades, se genera autom\u00e1ticamente la estructura de carpetas donde guardaremos nuestros programas. Dentro de la carpeta src podemos a\u00f1adir directamente los archivos Kotlin o, si lo preferimos, crear paquetes para organizar mejor el c\u00f3digo. | | En los proyectos creados con Gradle la estructura de carpetas var\u00eda ligeramente. Para a\u00f1adir nuestros programas debemos ir a la ruta src/main/kotlin , mientras que en la ra\u00edz del proyecto tambi\u00e9n se genera la carpeta resources (destinada a archivos auxiliares como datos o configuraciones) y los ficheros de configuraci\u00f3n propios de Gradle , como build.gradle.kts . | |","title":"\ud83d\udd39Proyecto nuevo"},{"location":"Idea/#estructura-de-los-proyectos-por-ud","text":"Por cada UD se crear\u00e1n uno o varios proyectos con una estructura fija para facilitar su correcci\u00f3n.","title":"\ud83d\udd39Estructura de los proyectos por UD"},{"location":"Idea/#ud-ficheros","text":"En esta unidad crearemos dos proyectos: Un proyecto sin Gradle , que llamaremos Ficheros , destinado a todos los ejemplos relacionados con el sistema de ficheros y el manejo de archivos. En este proyecto crearemos tres paquetes (sistema, contenido y formatos) para organizar los diferentes ejemplos. Un proyecto con Gradle , que llamaremos Ficheros_Gradle , en el que trabajaremos con ficheros de distintos formatos. A lo largo del tema se ir\u00e1 indicando en qu\u00e9 carpeta debe colocarse cada ejemplo. Proyecto Ficheros Proyecto Fichero_Gradle","title":"\ud83d\udd39UD Ficheros"},{"location":"Idea/#ud-bd-relacionales","text":"Para esta unidad did\u00e1ctica, crearemos un proyecto llamado BDRelacionales , configurado con Gradle . Este proyecto se utilizar\u00e1 para realizar todos los ejemplos y ejercicios relacionados con el acceso a bases de datos relacionales desde Kotlin. Con el fin de mantener una estructura organizada y diferenciada seg\u00fan el tipo de base de datos, se crear\u00e1n dos paquetes: Postgres : donde se incluir\u00e1n todos los ejemplos orientados al uso de bases de datos PostgreSQL. SQLite : donde se desarrollar\u00e1n los ejemplos utilizando bases de datos SQLite, tanto embebidas como externas. En cada apartado se especificar\u00e1 en qu\u00e9 paquete debe desarrollarse cada ejercicio, seg\u00fan la base de datos utilizada.","title":"\ud83d\udd39UD BD Relacionales"},{"location":"Idea/#ud-bd-documentales","text":"Para esta unidad did\u00e1ctica, crearemos un proyecto llamado BDNoSQL , configurado con Gradle . Este proyecto se utilizar\u00e1 para realizar todos los ejemplos y ejercicios relacionados con el acceso a Bases de Datos documentales desde Kotlin. Con el fin de mantener una estructura organizada y diferenciada seg\u00fan el controlador utilizado, se crear\u00e1n dos paquetes: mongo : donde se incluir\u00e1n los ejemplos en los que se utiliza el driver oficial de Mongo. kmongo : donde se incluir\u00e1n los ejemplos en los que se utiliza el driver KMongo. En cada apartado se especificar\u00e1 en qu\u00e9 paquete debe desarrollarse cada ejercicio, seg\u00fan el controlador utilizado.","title":"\ud83d\udd39UD BD Documentales"},{"location":"Kotlin/","text":"Kotlin En el m\u00f3dulo de Programaci\u00f3n, de 1\u00ba de DAM, hemos trabajado principalmente con Java, un lenguaje robusto, orientado a objetos y ampliamente utilizado en el desarrollo de aplicaciones empresariales. Gracias a Java, hemos aprendido conceptos clave como clases, objetos, herencia, interfaces y estructuras de control. A partir de ahora, en el m\u00f3dulo de Acceso a Datos (AD), vamos a continuar aplicando estos mismos conceptos, pero dando un paso m\u00e1s all\u00e1 y utilizando Kotlin , un lenguaje moderno, conciso y seguro que funciona sobre la m\u00e1quina virtual de Java (JVM). Fue desarrollado por JetBrains (los creadores de IntelliJ IDEA) y es 100% interoperable con Java. Los principales usos de Kotlin son: Aplicaciones Android \ud83d\udcf1 (mayor\u00eda actuales) Aplicaciones de escritorio (con Swing, JavaFX o Compose Desktop) Backends web (con frameworks como Ktor o Spring) Desarrollo multiplataforma (Kotlin Multiplatform) Existen muchos tutoriales sobre Kotlin en los que pod\u00e9is aprender su sintaxis. El sitio oficial es https://kotlinlang.org/docs/getting-started.html. En los aparatados siguietes se describen brevemente algunas particularidades propias del lenguaje Kotlin que son interesantes. \ud83d\udd39Gesti\u00f3n de excepciones Una excepci\u00f3n es un error que ocurre en tiempo de ejecuci\u00f3n y que interrumpe el flujo normal del programa (por ejemplo: dividir por cero, leer un archivo que no existe, etc.). La gesti\u00f3n de excepciones implica detectar, manejar y recuperarse de errores en el c\u00f3digo. Kotlin utiliza el mismo modelo de excepciones que Java, pero con algunas diferencias importantes. En Kotlin hay dos formas comunes de gestionar excepciones: 1. try-catch \u2192 Captura y manejo expl\u00edcito de errores Se utiliza cuando queremos atrapar y manejar una excepci\u00f3n que puede producirse en un bloque de c\u00f3digo. Sintaxis try { // C\u00f3digo que puede fallar } catch (e1: IOException) { // C\u00f3digo para manejar el error } catch (e2: Exception) { // C\u00f3digo para manejar el error } finally { // opcional. Finalizaci\u00f3n y liberaci\u00f3n de recursos } Ejemplo fun main() { try { val resultado = 10 / 0 println(\"Resultado: $resultado\") } catch (e: ArithmeticException) { println(\"Error: no se puede dividir entre cero.\") } finally { println(\"Fin del bloque try-catch.\") } } 2. use \u2192 Gesti\u00f3n autom\u00e1tica de recursos Se utiliza con objetos que implementan la interfaz Closeable o AutoCloseable (como archivos, streams, lectores, sockets...). Es el equivalente de try-with-resources en Java. Con use , Kotlin abre, utiliza y cierra autom\u00e1ticamente el recurso (como un archivo), incluso si ocurre una excepci\u00f3n. recurso.use { // Aqu\u00ed usas el recurso } - recurso es un objeto como BufferedReader, FileWriter, InputStream, etc. Ejemplo 1: Leer archivo con BufferedReader import java.io.BufferedReader import java.io.FileReader fun main() { BufferedReader(FileReader(\"archivo.txt\")).use { reader -> val linea = reader.readLine() println(linea) } } - Cuando el bloque use { ... } termina, el reader se cierra autom\u00e1ticamente. Ejemplo 2: Escribir archivo con FileWriter import java.io.FileWriter fun main() { FileWriter(\"archivo.txt\").use { it.write(\"Hola, Kotlin\\n\") } } Internamente, use hace lo mismo que esto: val writer = FileWriter(\"archivo.txt\") try { writer.write(\"Texto\") } finally { writer.close() } Ejemplo 3: Ejemplo con BufferedReader. Use se encarga de cerrar el BufferedReader autom\u00e1ticamente, aunque haya un error. import java.io.File fun main() { val archivo = File(\"datos.txt\") try { archivo.bufferedReader().use { reader -> println(\"Primera l\u00ednea: ${reader.readLine()}\") } } catch (e: Exception) { println(\"Error al leer el archivo: ${e.message}\") } } \ud83d\udd39Funciones lambda Kotlin permite trabajar de forma concisa con funciones lambda , utilizando la palabra clave it para referirse al par\u00e1metro impl\u00edcito cuando hay solo uno. Las funciones lambda son funciones definidas sin un nombre, utilizadas para operaciones simples y r\u00e1pidas, mejorando la legibilidad del c\u00f3digo y el rendimiento. Una lambda es una expresi\u00f3n de funci\u00f3n que se puede usar como valor. Kotlin la define con la siguiente sintaxis: { par\u00e1metro1, par\u00e1metro2 -> cuerpo de la funci\u00f3n } - Los par\u00e1metros van antes del ->. - El cuerpo (lo que hace la funci\u00f3n) va despu\u00e9s del ->. \ud83e\uddea Ejemplo b\u00e1sico: val saludar = { nombre: String -> println(\"Hola, $nombre\") } saludar(\"Ana\") - Aqu\u00ed saludar es una variable que almacena una lambda. - La lambda toma un String y muestra un saludo. - Su equivalen sin lambda ser\u00eda: fun saludar(nombre: String) { println(\"Hola, $nombre\") } fun main() { saludar(\"Ana\") } Kotlin permite pasar lambdas como argumentos de funciones de orden superior: val lista = listOf(1, 2, 3, 4) lista.forEach { println(it) } - { println(it) } es una lambda que se ejecuta para cada elemento de la lista. - it es el valor del elemento actual (ver it en el apartado siguiente). Lambdas sin par\u00e1metros val decirHola = { println(\"Hola\") } decirHola() Lambdas con m\u00faltiples par\u00e1metros val sumar = { a: Int, b: Int -> a + b } println(sumar(3, 4)) // Imprime 7 Comparaci\u00f3n con funciones tradicionales Funci\u00f3n tradicional Lambda equivalente fun saludar(nombre: String) { ... } val saludar = { nombre: String -> ... } return a + b dentro de una funci\u00f3n val suma = { a: Int, b: Int -> a + b } fun cuadrado(x: Int): Int = x * x val cuadrado = { x: Int -> x * x } fun sinParametros() = println(\"Hola\") val sinParametros = { println(\"Hola\") } it En Kotlin, it es el nombre impl\u00edcito que se le da al \u00fanico par\u00e1metro de una lambda cuando no se le asigna un nombre expl\u00edcito. Se usa cuando: Una lambda tiene solo un par\u00e1metro. No se necesita nombrar el par\u00e1metro expl\u00edcitamente. Se quiere un c\u00f3digo m\u00e1s conciso. Ejemplo val lista = listOf(\"Ana\", \"Luis\", \"Marta\") lista.forEach { println(it) } // 'it' representa cada elemento de la lista Es equivalente a: lista.forEach { nombre -> println(nombre) } \u00bfCu\u00e1ndo no se puede usar it? Si la lambda tiene m\u00e1s de un par\u00e1metro, debes nombrarlos expl\u00edcitamente. Si quieres mejorar la legibilidad, puedes usar nombres expl\u00edcitos aunque haya solo uno. Nota it es espec\u00edfico de Kotlin. En Java no existe como palabra clave ni como nombre impl\u00edcito de par\u00e1metros. \ud83d\udd39Data class En Kotlin, un data class es una clase especialmente dise\u00f1ada para almacenar informaci\u00f3n. Se usa cuando el objetivo principal es representar datos, no definir comportamiento o l\u00f3gica compleja. data class Persona(val nombre: String, val edad: Int) Los data class se utilizan para modelar objetos de datos (entidades, registros, documentos), simplificar el c\u00f3digo y facilitar operaciones como comparar, copiar o mostrar objetos. Uso principal Descripci\u00f3n breve Ficheros Representan la estructura de los datos que se leen o escriben en archivos (JSON, XML, CSV o binarios). Bases de datos relacionales Modelan entidades o registros de tablas para facilitar el acceso y manipulaci\u00f3n de datos. Bases de datos NoSQL Representan documentos o colecciones en sistemas como MongoDB o Firebase. APIs REST Sirven para enviar y recibir datos en formato JSON entre cliente y servidor. Interfaces gr\u00e1ficas Describen el estado o los elementos que maneja la interfaz de usuario. Modelo de dominio Definen las entidades principales de la l\u00f3gica de negocio de una aplicaci\u00f3n. Comunicaci\u00f3n y serializaci\u00f3n Permiten intercambiar informaci\u00f3n entre sistemas o guardar configuraciones estructuradas. Al declarar una clase con data , Kotlin genera autom\u00e1ticamente: M\u00e9todo Descripci\u00f3n toString() Devuelve una representaci\u00f3n legible del objeto. equals() Compara dos objetos por su contenido. hashCode() Genera un c\u00f3digo hash basado en los valores. copy() Crea una copia del objeto cambiando uno o m\u00e1s campos. componentN() Permite desestructurar el objeto. Ejemplo data class Persona(val nombre: String, val edad: Int) fun main() { val p1 = Persona(\"Ana\", 25) val p2 = Persona(\"Ana\", 25) val p3 = Persona(\"Luis\", 30) // toString(): muestra el contenido del objeto println(p1.toString()) // Resultado: Persona(nombre=Ana, edad=25) // equals(): compara el contenido de los objetos println(p1 == p2) // true println(p1 == p3) // false // hashCode(): genera un c\u00f3digo hash println(p1.hashCode()) println(p2.hashCode()) // Ambos tienen el mismo hashCode porque su contenido es igual // copy(): crea una copia con alguna modificaci\u00f3n val p4 = p1.copy(edad = 26) println(p4) // Resultado: Persona(nombre=Ana, edad=26) // componentN(): permite desestructurar el objeto val (nombre, edad) = p1 println(nombre) println(edad) } Requisitos Debe tener al menos una propiedad en el constructor principal. No puede ser abstract, open, sealed ni inner. Las propiedades deben ser val o var. Conclusi\u00f3n Los data class son una herramienta esencial en Kotlin. Permiten representar informaci\u00f3n de forma clara, reducen c\u00f3digo y facilitan la integraci\u00f3n con ficheros, bases de datos, APIs y componentes de interfaz.","title":"\ud83d\udd39Kotlin"},{"location":"Kotlin/#kotlin","text":"En el m\u00f3dulo de Programaci\u00f3n, de 1\u00ba de DAM, hemos trabajado principalmente con Java, un lenguaje robusto, orientado a objetos y ampliamente utilizado en el desarrollo de aplicaciones empresariales. Gracias a Java, hemos aprendido conceptos clave como clases, objetos, herencia, interfaces y estructuras de control. A partir de ahora, en el m\u00f3dulo de Acceso a Datos (AD), vamos a continuar aplicando estos mismos conceptos, pero dando un paso m\u00e1s all\u00e1 y utilizando Kotlin , un lenguaje moderno, conciso y seguro que funciona sobre la m\u00e1quina virtual de Java (JVM). Fue desarrollado por JetBrains (los creadores de IntelliJ IDEA) y es 100% interoperable con Java. Los principales usos de Kotlin son: Aplicaciones Android \ud83d\udcf1 (mayor\u00eda actuales) Aplicaciones de escritorio (con Swing, JavaFX o Compose Desktop) Backends web (con frameworks como Ktor o Spring) Desarrollo multiplataforma (Kotlin Multiplatform) Existen muchos tutoriales sobre Kotlin en los que pod\u00e9is aprender su sintaxis. El sitio oficial es https://kotlinlang.org/docs/getting-started.html. En los aparatados siguietes se describen brevemente algunas particularidades propias del lenguaje Kotlin que son interesantes.","title":"Kotlin"},{"location":"Kotlin/#gestion-de-excepciones","text":"Una excepci\u00f3n es un error que ocurre en tiempo de ejecuci\u00f3n y que interrumpe el flujo normal del programa (por ejemplo: dividir por cero, leer un archivo que no existe, etc.). La gesti\u00f3n de excepciones implica detectar, manejar y recuperarse de errores en el c\u00f3digo. Kotlin utiliza el mismo modelo de excepciones que Java, pero con algunas diferencias importantes. En Kotlin hay dos formas comunes de gestionar excepciones: 1. try-catch \u2192 Captura y manejo expl\u00edcito de errores Se utiliza cuando queremos atrapar y manejar una excepci\u00f3n que puede producirse en un bloque de c\u00f3digo. Sintaxis try { // C\u00f3digo que puede fallar } catch (e1: IOException) { // C\u00f3digo para manejar el error } catch (e2: Exception) { // C\u00f3digo para manejar el error } finally { // opcional. Finalizaci\u00f3n y liberaci\u00f3n de recursos } Ejemplo fun main() { try { val resultado = 10 / 0 println(\"Resultado: $resultado\") } catch (e: ArithmeticException) { println(\"Error: no se puede dividir entre cero.\") } finally { println(\"Fin del bloque try-catch.\") } } 2. use \u2192 Gesti\u00f3n autom\u00e1tica de recursos Se utiliza con objetos que implementan la interfaz Closeable o AutoCloseable (como archivos, streams, lectores, sockets...). Es el equivalente de try-with-resources en Java. Con use , Kotlin abre, utiliza y cierra autom\u00e1ticamente el recurso (como un archivo), incluso si ocurre una excepci\u00f3n. recurso.use { // Aqu\u00ed usas el recurso } - recurso es un objeto como BufferedReader, FileWriter, InputStream, etc. Ejemplo 1: Leer archivo con BufferedReader import java.io.BufferedReader import java.io.FileReader fun main() { BufferedReader(FileReader(\"archivo.txt\")).use { reader -> val linea = reader.readLine() println(linea) } } - Cuando el bloque use { ... } termina, el reader se cierra autom\u00e1ticamente. Ejemplo 2: Escribir archivo con FileWriter import java.io.FileWriter fun main() { FileWriter(\"archivo.txt\").use { it.write(\"Hola, Kotlin\\n\") } } Internamente, use hace lo mismo que esto: val writer = FileWriter(\"archivo.txt\") try { writer.write(\"Texto\") } finally { writer.close() } Ejemplo 3: Ejemplo con BufferedReader. Use se encarga de cerrar el BufferedReader autom\u00e1ticamente, aunque haya un error. import java.io.File fun main() { val archivo = File(\"datos.txt\") try { archivo.bufferedReader().use { reader -> println(\"Primera l\u00ednea: ${reader.readLine()}\") } } catch (e: Exception) { println(\"Error al leer el archivo: ${e.message}\") } }","title":"\ud83d\udd39Gesti\u00f3n de excepciones"},{"location":"Kotlin/#funciones-lambda","text":"Kotlin permite trabajar de forma concisa con funciones lambda , utilizando la palabra clave it para referirse al par\u00e1metro impl\u00edcito cuando hay solo uno. Las funciones lambda son funciones definidas sin un nombre, utilizadas para operaciones simples y r\u00e1pidas, mejorando la legibilidad del c\u00f3digo y el rendimiento. Una lambda es una expresi\u00f3n de funci\u00f3n que se puede usar como valor. Kotlin la define con la siguiente sintaxis: { par\u00e1metro1, par\u00e1metro2 -> cuerpo de la funci\u00f3n } - Los par\u00e1metros van antes del ->. - El cuerpo (lo que hace la funci\u00f3n) va despu\u00e9s del ->. \ud83e\uddea Ejemplo b\u00e1sico: val saludar = { nombre: String -> println(\"Hola, $nombre\") } saludar(\"Ana\") - Aqu\u00ed saludar es una variable que almacena una lambda. - La lambda toma un String y muestra un saludo. - Su equivalen sin lambda ser\u00eda: fun saludar(nombre: String) { println(\"Hola, $nombre\") } fun main() { saludar(\"Ana\") } Kotlin permite pasar lambdas como argumentos de funciones de orden superior: val lista = listOf(1, 2, 3, 4) lista.forEach { println(it) } - { println(it) } es una lambda que se ejecuta para cada elemento de la lista. - it es el valor del elemento actual (ver it en el apartado siguiente). Lambdas sin par\u00e1metros val decirHola = { println(\"Hola\") } decirHola() Lambdas con m\u00faltiples par\u00e1metros val sumar = { a: Int, b: Int -> a + b } println(sumar(3, 4)) // Imprime 7 Comparaci\u00f3n con funciones tradicionales Funci\u00f3n tradicional Lambda equivalente fun saludar(nombre: String) { ... } val saludar = { nombre: String -> ... } return a + b dentro de una funci\u00f3n val suma = { a: Int, b: Int -> a + b } fun cuadrado(x: Int): Int = x * x val cuadrado = { x: Int -> x * x } fun sinParametros() = println(\"Hola\") val sinParametros = { println(\"Hola\") } it En Kotlin, it es el nombre impl\u00edcito que se le da al \u00fanico par\u00e1metro de una lambda cuando no se le asigna un nombre expl\u00edcito. Se usa cuando: Una lambda tiene solo un par\u00e1metro. No se necesita nombrar el par\u00e1metro expl\u00edcitamente. Se quiere un c\u00f3digo m\u00e1s conciso. Ejemplo val lista = listOf(\"Ana\", \"Luis\", \"Marta\") lista.forEach { println(it) } // 'it' representa cada elemento de la lista Es equivalente a: lista.forEach { nombre -> println(nombre) } \u00bfCu\u00e1ndo no se puede usar it? Si la lambda tiene m\u00e1s de un par\u00e1metro, debes nombrarlos expl\u00edcitamente. Si quieres mejorar la legibilidad, puedes usar nombres expl\u00edcitos aunque haya solo uno. Nota it es espec\u00edfico de Kotlin. En Java no existe como palabra clave ni como nombre impl\u00edcito de par\u00e1metros.","title":"\ud83d\udd39Funciones lambda"},{"location":"Kotlin/#data-class","text":"En Kotlin, un data class es una clase especialmente dise\u00f1ada para almacenar informaci\u00f3n. Se usa cuando el objetivo principal es representar datos, no definir comportamiento o l\u00f3gica compleja. data class Persona(val nombre: String, val edad: Int) Los data class se utilizan para modelar objetos de datos (entidades, registros, documentos), simplificar el c\u00f3digo y facilitar operaciones como comparar, copiar o mostrar objetos. Uso principal Descripci\u00f3n breve Ficheros Representan la estructura de los datos que se leen o escriben en archivos (JSON, XML, CSV o binarios). Bases de datos relacionales Modelan entidades o registros de tablas para facilitar el acceso y manipulaci\u00f3n de datos. Bases de datos NoSQL Representan documentos o colecciones en sistemas como MongoDB o Firebase. APIs REST Sirven para enviar y recibir datos en formato JSON entre cliente y servidor. Interfaces gr\u00e1ficas Describen el estado o los elementos que maneja la interfaz de usuario. Modelo de dominio Definen las entidades principales de la l\u00f3gica de negocio de una aplicaci\u00f3n. Comunicaci\u00f3n y serializaci\u00f3n Permiten intercambiar informaci\u00f3n entre sistemas o guardar configuraciones estructuradas. Al declarar una clase con data , Kotlin genera autom\u00e1ticamente: M\u00e9todo Descripci\u00f3n toString() Devuelve una representaci\u00f3n legible del objeto. equals() Compara dos objetos por su contenido. hashCode() Genera un c\u00f3digo hash basado en los valores. copy() Crea una copia del objeto cambiando uno o m\u00e1s campos. componentN() Permite desestructurar el objeto. Ejemplo data class Persona(val nombre: String, val edad: Int) fun main() { val p1 = Persona(\"Ana\", 25) val p2 = Persona(\"Ana\", 25) val p3 = Persona(\"Luis\", 30) // toString(): muestra el contenido del objeto println(p1.toString()) // Resultado: Persona(nombre=Ana, edad=25) // equals(): compara el contenido de los objetos println(p1 == p2) // true println(p1 == p3) // false // hashCode(): genera un c\u00f3digo hash println(p1.hashCode()) println(p2.hashCode()) // Ambos tienen el mismo hashCode porque su contenido es igual // copy(): crea una copia con alguna modificaci\u00f3n val p4 = p1.copy(edad = 26) println(p4) // Resultado: Persona(nombre=Ana, edad=26) // componentN(): permite desestructurar el objeto val (nombre, edad) = p1 println(nombre) println(edad) } Requisitos Debe tener al menos una propiedad en el constructor principal. No puede ser abstract, open, sealed ni inner. Las propiedades deben ser val o var. Conclusi\u00f3n Los data class son una herramienta esencial en Kotlin. Permiten representar informaci\u00f3n de forma clara, reducen c\u00f3digo y facilitan la integraci\u00f3n con ficheros, bases de datos, APIs y componentes de interfaz.","title":"\ud83d\udd39Data class"},{"location":"docker/","text":"\ud83d\udd39Docker Docker es una herramienta que utiliza la tecnolog\u00eda de contenedores para empaquetar aplicaciones y sus dependencias en unidades port\u00e1tiles y ligeras. Esto garantiza que una aplicaci\u00f3n se ejecute de la misma manera en cualquier entorno, ya sea en una computadora local, un servidor de desarrollo, o en la nube. Toda la infomaci\u00f3n la pod\u00e9is encontrar en el sitio oficial de Docker https://docs.docker.com/manuals/ En esta imagen podemos ver como funciona la arquitectura b\u00e1sica de Docker. \ud83d\udd39Conceptos clave Im\u00e1genes : Una imagen es una plantilla de solo lectura que se utiliza para crear contenedores. A partir de una imagen pueden crearse m\u00faltiples contenedores. Docker permite crear nuevas im\u00e1genes bas\u00e1ndose en im\u00e1genes anteriores. Al crear una nueva imagen, simplemente estamos a\u00f1adiendo una capa a la imagen anterior, la que act\u00faa como base. Contenedores : Son instancias de una imagen. Pueden ser arrancados, parados y ejecutados. Cada contenedor Docker posee un identificador \u00fanico. Son entornos aislados que contienen todo lo necesario para ejecutar una aplicaci\u00f3n: c\u00f3digo, bibliotecas, dependencias, y configuraciones. A diferencia de las m\u00e1quinas virtuales, los contenedores comparten el mismo n\u00facleo del sistema operativo, lo que los hace m\u00e1s ligeros y eficientes. Docker Engine : Es el motor que ejecuta y gestiona los contenedores. Permite construir im\u00e1genes, iniciar contenedores y comunicarse con el hardware del sistema. Docker Hub : Es un repositorio en l\u00ednea donde se pueden almacenar y compartir im\u00e1genes de Docker. Ofrece una amplia variedad de im\u00e1genes predefinidas listas para usar. Por defecto, Docker utiliza esta plataforma de registro. Comandos habituales En el uso diario de Docker, existen una gran cantidad de comandos que permiten trabajar con im\u00e1genes, contenedores, redes y vol\u00famenes. Sin embargo, para iniciarse y poder manejarlo en clase, es suficiente con conocer un conjunto reducido de \u00f3rdenes b\u00e1sicas. La siguiente tabla recoge los 10 comandos m\u00e1s utilizados en un entorno educativo. Con ellos podr\u00e1s: Comando Descripci\u00f3n docker --version Muestra la versi\u00f3n instalada de Docker. docker pull <imagen> Descarga una imagen desde Docker Hub. docker images Lista las im\u00e1genes descargadas en el sistema. docker ps -a Lista todos los contenedores (activos y detenidos). docker run -it <imagen> Crea y arranca un contenedor en modo interactivo con terminal. docker start <contenedor> Inicia un contenedor detenido. docker stop <contenedor> Detiene un contenedor en ejecuci\u00f3n. docker rm <contenedor> Elimina un contenedor detenido. docker build -t <nombre> . Construye una imagen a partir de un Dockerfile . docker-compose up Levanta servicios definidos en docker-compose.yml . docker save -o <fichero> <imagen> Copia de seguridad de una imagen en un fichero. docker load -i <fichero> Importar un fichero para crear una imagen. Para saber m\u00e1s pod\u00e9is consultar su p\u00e1gina Web: https://www.docker.com/ \ud83d\udd39Instalaci\u00f3n en Ubuntu https://docs.docker.com/desktop/setup/install/linux/ubuntu/ https://docs.docker.com/engine/install/ubuntu/ \ud83d\udd39Requisitos previos Aseg\u00farate de que tu sistema est\u00e1 actualizado: sudo apt update && sudo apt upgrade -y Desinstala versiones antiguas de Docker si est\u00e1n instaladas: sudo apt remove docker docker-engine docker.io containerd runc \ud83d\udd39Pasos para instalar Docker 1) Instalar paquetes necesarios: sudo apt install apt-transport-https ca-certificates curl software-properties-common 2) Agregar la clave GPG de Docker: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 3) Agregar el repositorio de Docker: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 4) Actualizar el \u00edndice de paquetes e instalar Docker: sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io 5) Verificar la instalaci\u00f3n: docker --version 6) Habilitar Docker para que inicie con el sistema: sudo systemctl enable docker 7) Opcional: Permitir ejecutar Docker sin sudo : sudo usermod -aG docker $USER # Sal y vuelve a iniciar sesi\u00f3n para aplicar los cambios \ud83d\udd39Probar Docker Ejecuta el siguiente comando para probar si Docker est\u00e1 funcionando correctamente: docker run hello-world \ud83d\udd39Instalaci\u00f3n en Windows https://docs.docker.com/desktop/setup/install/windows-install/ https://docs.docker.com/docker-for-windows/install/ \ud83d\udd39Requisitos previos Windows 10 o superior con soporte para WSL 2. Habilitar virtualizaci\u00f3n en el BIOS. \ud83d\udd39Pasos para instalar Docker 1) Descargar Docker Desktop: Ve al sitio oficial de Docker y descarga Docker Desktop: https://www.docker.com/products/docker-desktop v\u00eddeo de instalaci\u00f3n 2) Ejecutar el instalador: Sigue las instrucciones del asistente de instalaci\u00f3n. 3) Habilitar WSL 2: Aseg\u00farate de que WSL 2 est\u00e1 habilitado en tu sistema: dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart wsl --set-default-version 2 4) Configurar Docker Desktop: Abre Docker Desktop y sigue las instrucciones para configurar WSL 2. 5) Verificar la instalaci\u00f3n: Abre una terminal y ejecuta: docker --version 6) Probar Docker: Ejecuta el comando: docker run hello-world \ud83d\udd39Docker Compose Docker Compose es una herramienta de Docker que permite definir y gestionar aplicaciones multicontenedor de forma sencilla. Docker Desktop (Windows/Mac) \u2192 ya lo trae integrado. Linux con Docker Engine \u2192 hay que instalarlo aparte. Con Docker Compose puedes describir en un archivo de configuraci\u00f3n (normalmente docker-compose.yml) todos los servicios que forman tu aplicaci\u00f3n. Comandos b\u00e1sicos de Docker Compose Comando Descripci\u00f3n docker-compose up Levanta los servicios definidos en el archivo docker-compose.yml . docker-compose down Detiene y elimina contenedores, redes y vol\u00famenes creados. docker-compose ps Muestra el estado de los servicios gestionados por Compose. docker-compose logs Muestra los registros (logs) de los servicios en ejecuci\u00f3n. \ud83d\udc49 Ejemplo de archivo docker-compose.yml m\u00ednimo: version: \"3.9\" services: postgres: image: postgres:16 container_name: mi_postgres environment: POSTGRES_USER: usuario POSTGRES_PASSWORD: clave POSTGRES_DB: mi_bd ports: - \"5432:5432\" volumes: - ./data:/var/lib/postgresql/data Con este archivo, solo necesitar\u00edas ejecutar: docker-compose up y ya tendr\u00edas corriendo un contenedor con PostgreSQL configurado. \ud83d\udd39Copia y carga de Im\u00e1genes Construcci\u00f3n de una imagen : Los desarrolladores crean un archivo llamado Dockerfile, donde se especifican los pasos para construir la imagen de una aplicaci\u00f3n. A partir del Dockerfile, Docker genera una imagen. Distribuci\u00f3n de im\u00e1genes : Las im\u00e1genes pueden ser subidas a Docker Hub u otros registros privados para compartirlas y utilizarlas en diferentes sistemas. Una vez tengamos una imagen local en nuestro sistema, podemos hacer una copia de la misma , ya sea como copia de seguridad o como forma de transportarla a otros sistemas mediante el comando docker save . - docker save -o copiaSeguridad.tar imagen https://docs.docker.com/engine/reference/commandline/save/ Si queremos importar el fichero para crear una imagen en nuestra m\u00e1quina, podemos usar \u201cdocker load\u201d. - docker load -i copiaSeguridad.tar https://docs.docker.com/engine/reference/commandline/load/","title":"\ud83d\udd39Docker"},{"location":"docker/#docker","text":"Docker es una herramienta que utiliza la tecnolog\u00eda de contenedores para empaquetar aplicaciones y sus dependencias en unidades port\u00e1tiles y ligeras. Esto garantiza que una aplicaci\u00f3n se ejecute de la misma manera en cualquier entorno, ya sea en una computadora local, un servidor de desarrollo, o en la nube. Toda la infomaci\u00f3n la pod\u00e9is encontrar en el sitio oficial de Docker https://docs.docker.com/manuals/ En esta imagen podemos ver como funciona la arquitectura b\u00e1sica de Docker.","title":"\ud83d\udd39Docker"},{"location":"docker/#conceptos-clave","text":"Im\u00e1genes : Una imagen es una plantilla de solo lectura que se utiliza para crear contenedores. A partir de una imagen pueden crearse m\u00faltiples contenedores. Docker permite crear nuevas im\u00e1genes bas\u00e1ndose en im\u00e1genes anteriores. Al crear una nueva imagen, simplemente estamos a\u00f1adiendo una capa a la imagen anterior, la que act\u00faa como base. Contenedores : Son instancias de una imagen. Pueden ser arrancados, parados y ejecutados. Cada contenedor Docker posee un identificador \u00fanico. Son entornos aislados que contienen todo lo necesario para ejecutar una aplicaci\u00f3n: c\u00f3digo, bibliotecas, dependencias, y configuraciones. A diferencia de las m\u00e1quinas virtuales, los contenedores comparten el mismo n\u00facleo del sistema operativo, lo que los hace m\u00e1s ligeros y eficientes. Docker Engine : Es el motor que ejecuta y gestiona los contenedores. Permite construir im\u00e1genes, iniciar contenedores y comunicarse con el hardware del sistema. Docker Hub : Es un repositorio en l\u00ednea donde se pueden almacenar y compartir im\u00e1genes de Docker. Ofrece una amplia variedad de im\u00e1genes predefinidas listas para usar. Por defecto, Docker utiliza esta plataforma de registro. Comandos habituales En el uso diario de Docker, existen una gran cantidad de comandos que permiten trabajar con im\u00e1genes, contenedores, redes y vol\u00famenes. Sin embargo, para iniciarse y poder manejarlo en clase, es suficiente con conocer un conjunto reducido de \u00f3rdenes b\u00e1sicas. La siguiente tabla recoge los 10 comandos m\u00e1s utilizados en un entorno educativo. Con ellos podr\u00e1s: Comando Descripci\u00f3n docker --version Muestra la versi\u00f3n instalada de Docker. docker pull <imagen> Descarga una imagen desde Docker Hub. docker images Lista las im\u00e1genes descargadas en el sistema. docker ps -a Lista todos los contenedores (activos y detenidos). docker run -it <imagen> Crea y arranca un contenedor en modo interactivo con terminal. docker start <contenedor> Inicia un contenedor detenido. docker stop <contenedor> Detiene un contenedor en ejecuci\u00f3n. docker rm <contenedor> Elimina un contenedor detenido. docker build -t <nombre> . Construye una imagen a partir de un Dockerfile . docker-compose up Levanta servicios definidos en docker-compose.yml . docker save -o <fichero> <imagen> Copia de seguridad de una imagen en un fichero. docker load -i <fichero> Importar un fichero para crear una imagen. Para saber m\u00e1s pod\u00e9is consultar su p\u00e1gina Web: https://www.docker.com/","title":"\ud83d\udd39Conceptos clave"},{"location":"docker/#instalacion-en-ubuntu","text":"https://docs.docker.com/desktop/setup/install/linux/ubuntu/ https://docs.docker.com/engine/install/ubuntu/","title":"\ud83d\udd39Instalaci\u00f3n en Ubuntu"},{"location":"docker/#requisitos-previos","text":"Aseg\u00farate de que tu sistema est\u00e1 actualizado: sudo apt update && sudo apt upgrade -y Desinstala versiones antiguas de Docker si est\u00e1n instaladas: sudo apt remove docker docker-engine docker.io containerd runc","title":"\ud83d\udd39Requisitos previos"},{"location":"docker/#pasos-para-instalar-docker","text":"1) Instalar paquetes necesarios: sudo apt install apt-transport-https ca-certificates curl software-properties-common 2) Agregar la clave GPG de Docker: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 3) Agregar el repositorio de Docker: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 4) Actualizar el \u00edndice de paquetes e instalar Docker: sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io 5) Verificar la instalaci\u00f3n: docker --version 6) Habilitar Docker para que inicie con el sistema: sudo systemctl enable docker 7) Opcional: Permitir ejecutar Docker sin sudo : sudo usermod -aG docker $USER # Sal y vuelve a iniciar sesi\u00f3n para aplicar los cambios","title":"\ud83d\udd39Pasos para instalar Docker"},{"location":"docker/#probar-docker","text":"Ejecuta el siguiente comando para probar si Docker est\u00e1 funcionando correctamente: docker run hello-world","title":"\ud83d\udd39Probar Docker"},{"location":"docker/#instalacion-en-windows","text":"https://docs.docker.com/desktop/setup/install/windows-install/ https://docs.docker.com/docker-for-windows/install/","title":"\ud83d\udd39Instalaci\u00f3n en Windows"},{"location":"docker/#requisitos-previos_1","text":"Windows 10 o superior con soporte para WSL 2. Habilitar virtualizaci\u00f3n en el BIOS.","title":"\ud83d\udd39Requisitos previos"},{"location":"docker/#pasos-para-instalar-docker_1","text":"1) Descargar Docker Desktop: Ve al sitio oficial de Docker y descarga Docker Desktop: https://www.docker.com/products/docker-desktop v\u00eddeo de instalaci\u00f3n 2) Ejecutar el instalador: Sigue las instrucciones del asistente de instalaci\u00f3n. 3) Habilitar WSL 2: Aseg\u00farate de que WSL 2 est\u00e1 habilitado en tu sistema: dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart wsl --set-default-version 2 4) Configurar Docker Desktop: Abre Docker Desktop y sigue las instrucciones para configurar WSL 2. 5) Verificar la instalaci\u00f3n: Abre una terminal y ejecuta: docker --version 6) Probar Docker: Ejecuta el comando: docker run hello-world","title":"\ud83d\udd39Pasos para instalar Docker"},{"location":"docker/#docker-compose","text":"Docker Compose es una herramienta de Docker que permite definir y gestionar aplicaciones multicontenedor de forma sencilla. Docker Desktop (Windows/Mac) \u2192 ya lo trae integrado. Linux con Docker Engine \u2192 hay que instalarlo aparte. Con Docker Compose puedes describir en un archivo de configuraci\u00f3n (normalmente docker-compose.yml) todos los servicios que forman tu aplicaci\u00f3n. Comandos b\u00e1sicos de Docker Compose Comando Descripci\u00f3n docker-compose up Levanta los servicios definidos en el archivo docker-compose.yml . docker-compose down Detiene y elimina contenedores, redes y vol\u00famenes creados. docker-compose ps Muestra el estado de los servicios gestionados por Compose. docker-compose logs Muestra los registros (logs) de los servicios en ejecuci\u00f3n. \ud83d\udc49 Ejemplo de archivo docker-compose.yml m\u00ednimo: version: \"3.9\" services: postgres: image: postgres:16 container_name: mi_postgres environment: POSTGRES_USER: usuario POSTGRES_PASSWORD: clave POSTGRES_DB: mi_bd ports: - \"5432:5432\" volumes: - ./data:/var/lib/postgresql/data Con este archivo, solo necesitar\u00edas ejecutar: docker-compose up y ya tendr\u00edas corriendo un contenedor con PostgreSQL configurado.","title":"\ud83d\udd39Docker Compose"},{"location":"docker/#copia-y-carga-de-imagenes","text":"Construcci\u00f3n de una imagen : Los desarrolladores crean un archivo llamado Dockerfile, donde se especifican los pasos para construir la imagen de una aplicaci\u00f3n. A partir del Dockerfile, Docker genera una imagen. Distribuci\u00f3n de im\u00e1genes : Las im\u00e1genes pueden ser subidas a Docker Hub u otros registros privados para compartirlas y utilizarlas en diferentes sistemas. Una vez tengamos una imagen local en nuestro sistema, podemos hacer una copia de la misma , ya sea como copia de seguridad o como forma de transportarla a otros sistemas mediante el comando docker save . - docker save -o copiaSeguridad.tar imagen https://docs.docker.com/engine/reference/commandline/save/ Si queremos importar el fichero para crear una imagen en nuestra m\u00e1quina, podemos usar \u201cdocker load\u201d. - docker load -i copiaSeguridad.tar https://docs.docker.com/engine/reference/commandline/load/","title":"\ud83d\udd39Copia y carga de Im\u00e1genes"},{"location":"ejercicios/","text":"\ud83d\udd39Formato entrega ejercicios \ud83d\udcbb Todos los ejercicios se hacen sobre la aplicaci\u00f3n IntelliJ Ultimate . \ud83d\udcc2 Cada ejercicio se entregar\u00e1 en un proyecto diferente y se subir\u00e1 en la tarea correspondiente comprimi\u00e9ndolo en un archivo .zip . \u26a0\ufe0f El ejercicio que no se suba en su entrega correspondiente no podr\u00e1 ser calificado .","title":"\ud83d\udd39Entrega Ejercicios"},{"location":"ejercicios/#formato-entrega-ejercicios","text":"\ud83d\udcbb Todos los ejercicios se hacen sobre la aplicaci\u00f3n IntelliJ Ultimate . \ud83d\udcc2 Cada ejercicio se entregar\u00e1 en un proyecto diferente y se subir\u00e1 en la tarea correspondiente comprimi\u00e9ndolo en un archivo .zip . \u26a0\ufe0f El ejercicio que no se suba en su entrega correspondiente no podr\u00e1 ser calificado .","title":"\ud83d\udd39Formato entrega ejercicios"},{"location":"intro/","text":"\ud83d\udd39 Introducci\u00f3n Todos nuestros programas estar\u00e1n realizados en Kotlin , lenguaje desarrollado por JetBrains, y que est\u00e1 por encima de Java, por lo que todos los programas, clases... , realizados en Java, los podremos utilizar sin problemas, y adem\u00e1s nos permitir\u00e1 una programaci\u00f3n mucho m\u00e1s c\u00f3moda. Adem\u00e1s, es el lenguaje que utilizar\u00e1 tanto en el m\u00f3dulo de PMDM como en el de DI . IntelliJ IDEA es la herramienta ideal para Kotlin porque est\u00e1 dise\u00f1ada pensando en \u00e9l, especialmente porque lo desarroll\u00f3 JetBrains (los creadores de Kotlin). Reduce el tiempo de configuraci\u00f3n, nos da herramientas avanzadas para escribir y depurar c\u00f3digo, y simplifica todo el proceso de desarrollo. En este tema encontrar\u00e9is explicada la instalaci\u00f3n, configuraci\u00f3n y estructura de los proyectos correspondientes a cada una de las unidades did\u00e1cticas del m\u00f3dulo. De momento, solo ten\u00e9is disponible la estructura de las dos primeras unidades \u2014Ficheros y Bases de Datos Relacionales\u2014, pero el resto se ir\u00e1 habilitando a medida que avancemos en el temario. Es muy importante que sig\u00e1is la estructura indicada, ya que esto facilita tanto la correcci\u00f3n de los trabajos como la entrega de los ejercicios, cuya forma de presentaci\u00f3n est\u00e1 detallada en el apartado correspondiente.","title":"\ud83d\udd39Introducci\u00f3n"},{"location":"intro/#introduccion","text":"Todos nuestros programas estar\u00e1n realizados en Kotlin , lenguaje desarrollado por JetBrains, y que est\u00e1 por encima de Java, por lo que todos los programas, clases... , realizados en Java, los podremos utilizar sin problemas, y adem\u00e1s nos permitir\u00e1 una programaci\u00f3n mucho m\u00e1s c\u00f3moda. Adem\u00e1s, es el lenguaje que utilizar\u00e1 tanto en el m\u00f3dulo de PMDM como en el de DI . IntelliJ IDEA es la herramienta ideal para Kotlin porque est\u00e1 dise\u00f1ada pensando en \u00e9l, especialmente porque lo desarroll\u00f3 JetBrains (los creadores de Kotlin). Reduce el tiempo de configuraci\u00f3n, nos da herramientas avanzadas para escribir y depurar c\u00f3digo, y simplifica todo el proceso de desarrollo. En este tema encontrar\u00e9is explicada la instalaci\u00f3n, configuraci\u00f3n y estructura de los proyectos correspondientes a cada una de las unidades did\u00e1cticas del m\u00f3dulo. De momento, solo ten\u00e9is disponible la estructura de las dos primeras unidades \u2014Ficheros y Bases de Datos Relacionales\u2014, pero el resto se ir\u00e1 habilitando a medida que avancemos en el temario. Es muy importante que sig\u00e1is la estructura indicada, ya que esto facilita tanto la correcci\u00f3n de los trabajos como la entrega de los ejercicios, cuya forma de presentaci\u00f3n est\u00e1 detallada en el apartado correspondiente.","title":"\ud83d\udd39 Introducci\u00f3n"}]}